<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>小下同学 - 找不到北，就多看东西</title><meta name="author" content="安小下同学"><meta name="copyright" content="安小下同学"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="website">
<meta property="og:title" content="小下同学">
<meta property="og:url" content="https://blog.linganmin.cn/page/3/index.html">
<meta property="og:site_name" content="小下同学">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://graph.linganmin.cn/200118/06177d8b92c66f2c3a6fd82cca544f51">
<meta property="article:author" content="安小下同学">
<meta property="article:tag" content="安小下同学,闵令安,令安,小下,亲爱的安小下同学,小下同学,小小小下,前端,js,jquery,javascript,html5,开发者,程序猿,程序媛,极客,编程,代码,开源,IT网站,Developer,Programmer,Coder,Geek,html,css,css3,用户体验,php,laravel,golang,phper,docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://graph.linganmin.cn/200118/06177d8b92c66f2c3a6fd82cca544f51"><link rel="shortcut icon" href="https://graph.linganmin.cn/201206/fe9c5e8ef76354659ab9c6c8764d6f3d"><link rel="canonical" href="https://blog.linganmin.cn/page/3/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="KrvBZb2kkH"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/pluginsSrc/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b4e74da1cb3c8b4a65da55116b8cba6f";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.min.js',
      css: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '小下同学',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2022-12-09 22:10:24'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://graph.linganmin.cn/200118/06177d8b92c66f2c3a6fd82cca544f51" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url('https://graph.linganmin.cn/200120/81525dc7a1a92645199b36b2e20cc2c8?x-oss-process=image/format,webp/quality,q_40')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小下同学</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">小下同学</h1><div id="site-subtitle"><span id="subtitle"></span></div><div id="site_social_icons"><a class="social-icon" href="https://github.com/linganmin" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:saboranmin@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://www.weibo.com/u/1793963601" target="_blank" title="Weibo"><i class="fab fa-weibo"></i></a></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="post_cover left"><a href="/2021/01/07/others/consistency/" title="分布式架构中的”一致性“"><img class="post_bg" src="https://graph.linganmin.cn/201007/87122d3084205a5821b1e39413e84349?x-oss-process=image/format,webp/quality,q_10" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式架构中的”一致性“"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/01/07/others/consistency/" title="分布式架构中的”一致性“">分布式架构中的”一致性“</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-01-06T23:30:20.000Z" title="发表于 2021-01-07 07:30:20">2021-01-07</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Frchitecture/">Frchitecture</a></span></div><div class="content">一致性什么是 CAP
Consistent
一致性
同样的数据在分布式系统中所有地方都是被复制成相同的。




Available
可用性
所有在分布式系统活跃的节点都能处理操作且响应查询。




Partition Tolerant
分区容错性
在两个复制系统之间，如果发生了计划之外的网络连接问题，有一套容错性设计来保证。






CAP 是分布式系统中进行平衡的理论。一般情况下，CAP 理论任务你不能同时拥有上述三种，只能同时选择两种。

数据一致性
复制是导致出现数据一致性问题的唯一原因

强一致性（线性一致性）和弱一致性
强一致性
系统中的某个数据被成功更新后，后续任何对于该数据的读操作都将得到更新后的值。简而言之就是，在任意时刻，所有节点的数据是一样的。
写时复制，复制是同步的。主库需要等待从库的确认，确认从库已经收到写入操作。
缺点是，保证了强一致性，必然会损耗可用性。




弱一致性
复制是异步的。不需要等待从库响应。



半同步概念使一个从库保证和主库是强一致性，其他从库保持弱一致性。如果强一致性从库出现问题，则使另一个从库和主库保持强一致性。这样可以确保永 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2020/12/15/others/knowledge_hierarchy/" title="知识体系梳理"><img class="post_bg" src="https://graph.linganmin.cn/200822/43c6bc33f3be83618d4f9cc69bf00fb0?x-oss-process=image/format,webp/quality,q_10" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="知识体系梳理"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/12/15/others/knowledge_hierarchy/" title="知识体系梳理">知识体系梳理</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-12-15T14:03:00.000Z" title="发表于 2020-12-15 22:03:00">2020-12-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Golang/">Golang</a></span></div><div class="content">在微服务里面提倡，不同的模块单元用最实惠的语言。
Golang
Goroutine 生命周期
野生goroutine
https://zhuanlan.zhihu.com/p/328591249
https://www.syncd.cn/go_advance_note2/


https://zhuanlan.zhihu.com/p/74090074


Go 的内存模型
https://www.jianshu.com/p/5e44168f47a3


原子锁
atomic
data race


cow copy on write（COW)写时复制
BGSave redis


errgroup
interface nil
https://www.cnblogs.com/52php/p/7363101.html


context
不要修改之前的值，生成新的context，copy on write 方式生成新的
参考 rpc metadata 实现



PHPKubernetes</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2020/10/07/golang/golang-slice-array/" title="「深入学习 Golang」之 切片（slice）、数组（array）"><img class="post_bg" src="https://graph.linganmin.cn/201007/87122d3084205a5821b1e39413e84349?x-oss-process=image/format,webp/quality,q_10" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="「深入学习 Golang」之 切片（slice）、数组（array）"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/10/07/golang/golang-slice-array/" title="「深入学习 Golang」之 切片（slice）、数组（array）">「深入学习 Golang」之 切片（slice）、数组（array）</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-10-06T21:30:20.000Z" title="发表于 2020-10-07 05:30:20">2020-10-07</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Golang/">Golang</a></span></div><div class="content">数组
数组是由相同类型元素组合成的数据结构，计算机会为数组分配一块连续的内存来保存其中的元素。我们可以利用数组中元素的索引，快速访问元素对应的存储地址。


Go 语言中数组在初始化之后大小是无法改变的。
存储元素类型相同，但大小不同的数组在 GO 语言中是完全不同的



创建123arr1 := [3]uint64&#123;1,2,3&#125; // 显示指定数组大小arr2 := [...]uint64&#123;1,2,3&#125; // 在编译期间通过源码对数组大小进行推导

如果数组中元素个数小于或等于4个，那么所有的变量都会直接在栈上初始化；如果数组元素大于4个，变量就会在静态存储区初始化然后拷贝到栈上。
访问和赋值数组在内存中就是一连串的内存空间，表示数组的方法是一个指向数组开头的指针、数组中元素的数量以及数组中元素类型站的空间大小。
如果我们不知道数组中元素的数量，访问时就可能发生越界，数组访问越界是非常严重的错误。
对数组的访问和复制需要同时依赖编译器和运行时，它的大多数操作在编译期间都会转换成对内存的直接读写，在中间代码生产期间还会插入运行时方法panicI ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2020/10/03/golang/golang-gpm/" title="「深入学习 Golang」之 GPM"><img class="post_bg" src="https://graph.linganmin.cn/201007/87122d3084205a5821b1e39413e84349?x-oss-process=image/format,webp/quality,q_10" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="「深入学习 Golang」之 GPM"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/10/03/golang/golang-gpm/" title="「深入学习 Golang」之 GPM">「深入学习 Golang」之 GPM</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-10-03T07:40:34.000Z" title="发表于 2020-10-03 15:40:34">2020-10-03</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Golang/">Golang</a></span></div><div class="content">相关术语runtimeruntime在 Golang 程序中很重要，runtime包含了调度、内存、垃圾回收、内部数据结构、定时器和各种系统调用的封装等。
schedulerscheduler是指调度器，主要工作是将准备好运行的Goroutine分散到工作线程中执行。
TLS(thread local storage)TLS代表每个线程中的本地数据，每个线程写入 TLS 的数据相互独立互不影响，Golang 的协程非常依赖 TLS 机制。TLS 里会存储当前线程中的Goroutine和其所属的Machine实例。
spiningspining表示重复某块代码。
systemstack、mcall 或 asmcgocallTODO 这个没看懂。。。。。。
调度模型（GPM）线程模型Golang 中的goroutine和go scheduler的底层实现都是属于两级线程模型



KSE是操作系统本身内核态的线程的简称（Kernel Scheduler Entities）。

我们现在的计算机语言，可以狭义的认为是一种“软件”，它们中所谓的“线程”，往往是用户态的线程，用户态线程和操作系统 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2020/09/20/travel/dc-island/" title="2020.10.01 去「大陈岛」看海了"><img class="post_bg" src="https://graph.linganmin.cn/201004/3190e5ac9987d0ad0c09eeae9ffe680b?x-oss-process=image/format,webp/quality,q_3" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2020.10.01 去「大陈岛」看海了"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/09/20/travel/dc-island/" title="2020.10.01 去「大陈岛」看海了">2020.10.01 去「大陈岛」看海了</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-09-20T07:06:34.000Z" title="发表于 2020-09-20 15:06:34">2020-09-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%97%85%E8%A1%8C/">旅行</a></span></div><div class="content">大陈岛分上大陈和下大陈，下大陈开发相对完善，一般住宿都会在下大陈，下大陈比较值得去的应该就是甲午岩景区，沿着峭壁一路走到到尽头是观景台，可以面朝大海，如果晴天可以在观景台看日出。上大陈新开发了乌沙头风景区（目前是免费开放，但需要提前预约，在公众号大美大陈，我去的时候人比较少所以没要查票，当然我也没预约上），这里有乌沙滩、观景台、泡洞、滨海(绝壁)栈道，值得一去。
有一点需要注意的是，整个大陈岛的地图在各大地图软件上均不完善，很多路和景点在地图上都查不到，或者查到的是不对的。上大陈尤为明显，我骑小电驴饶了好久好久。惨~~~
行程
提前 15 天，12306 订上海 -&gt; 台州高铁
提前 3 天，公众号大美大陈买椒江 -&gt; 下大陈岛船票
有快船和慢船，建议慢船
建议提前备好晕船药或晕船贴


09.30 07:00 虹桥枢纽 4 路到高铁站乘车出发前往台州
11:20 到台州站，打车前往椒江七号码头
12:30 登船，驶向深蓝（东海方向）
因为海上风浪很大，所以船上是不能上甲板的，这一点和舟山群岛不太一样，舟山那边属于近海一般慢船是可以上甲板的


14:10 到达下大陈岛

 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2020/09/15/golang/golang-goroutine/" title="「深入学习 Golang」之 Goroutine"><img class="post_bg" src="https://graph.linganmin.cn/201007/87122d3084205a5821b1e39413e84349?x-oss-process=image/format,webp/quality,q_10" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="「深入学习 Golang」之 Goroutine"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/09/15/golang/golang-goroutine/" title="「深入学习 Golang」之 Goroutine">「深入学习 Golang」之 Goroutine</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-09-14T22:40:34.000Z" title="发表于 2020-09-15 06:40:34">2020-09-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Golang/">Golang</a></span></div><div class="content">进程、线程、协程进程
进程是系统资源分配的最小单位
进程包括text region，data region和stack region等
进程的创建和销毁都是系统资源级别的，因此是一种比较昂贵的操作
进程是抢占式调度，他有三个状态：等待态、就绪态、运行态
进程之间是相互隔离的，每个进程有各自的系统资源，更加安全同时也带来了进程间通信不便的问题
进程是线程的载体

线程
同一个进程的多个线程共享进程的资源
每个线程也拥有自己的一少部分独立的资源
线程相比进程更加轻量，同一个进程内的多个线程通信比多个进程间通信容易，同时也带来了同步、互斥和线程安全的问题

协程
协程调度不需要内核参与，是完全由用户态程序决定的
协程不是抢占式调度，多个协程进行协作调度，避免了系统切换开销导致 CPU 使用率高

goroutine协程并不是 Go 语言的特有机制，Go 语言是在原生语言层面支持的的协程。Go 语言可以通过通信实现 goroutine 之间的数据共享。

Golang 中，不要通过共享内存来通信，而应该通过通信来共享内存！


创建一个 goroutine 不需要太多的内存，大概 2KB 左右 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2020/09/11/k8s/k8s-execution-flow/" title="「Kubernetes 拾遗」之 输入 kubectl run/create/apply 之后到底发生了什么"><img class="post_bg" src="https://graph.linganmin.cn/200911/4043741d339ab2812a46836518975aa7?x-oss-process=image/format,webp/quality,q_10" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="「Kubernetes 拾遗」之 输入 kubectl run/create/apply 之后到底发生了什么"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/09/11/k8s/k8s-execution-flow/" title="「Kubernetes 拾遗」之 输入 kubectl run/create/apply 之后到底发生了什么">「Kubernetes 拾遗」之 输入 kubectl run/create/apply 之后到底发生了什么</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-09-11T14:40:34.000Z" title="发表于 2020-09-11 22:40:34">2020-09-11</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Kubernetes/">Kubernetes</a></span></div><div class="content">周四的时候参加我司容器组大佬的课，问到一个问题：

kubectl run nginx --image=nginx --replicals=3 当这行命令在终端敲下回车键之后你会看到很快有三个nginx pod创建在集群的worker节点上，但当敲下回车键的时候kubernetes背后都做了什么呢？

自认为对 k8s 还算熟悉的在下一下子懵了，好像知道但又说不清楚。那今天就系统性的查资料+实践总结一下吧。

kubectl客户端验证执行客户端验证，确保非法请求（创建的资源不存在、镜像格式不正确等）的快速失败，减少对kuber-apiserver的不必要请求提升系统性能。
生成运行时对象使用generator根据需要创建资源类型来构建运行时对象(runtime object)

如果显示的设置了--generator参数，kubectl 将使用指定的生成器。如果没有指定生成器，kubectl 会根据其他参数自动选择要使用的生成器。具体优先级如下：

1234--schedule=&lt;schedule&gt;  CronJob--restart=Always       Deploy ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2020/09/11/k8s/k8s-framework/" title="「Kubernetes 拾遗」之 K8S 基础知识"><img class="post_bg" src="https://graph.linganmin.cn/200911/4043741d339ab2812a46836518975aa7?x-oss-process=image/format,webp/quality,q_10" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="「Kubernetes 拾遗」之 K8S 基础知识"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/09/11/k8s/k8s-framework/" title="「Kubernetes 拾遗」之 K8S 基础知识">「Kubernetes 拾遗」之 K8S 基础知识</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-09-10T21:40:34.000Z" title="发表于 2020-09-11 05:40:34">2020-09-11</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Kubernetes/">Kubernetes</a></span></div><div class="content">架构图
核心组件
API Server

用户唯一可以直接进行交互的 k8s 组件
提供了认证、授权、访问控制、api 注册和发现等机制


ETCD

集群数据库
存储了整个集群的配置和状态


Controller Manager

负责维护集群的状态，比如故障检测、自动扩展、滚动更新等


Scheduler

负责资源的调度。按照预定的调度策略将 pod 调度到相应机器上


Kubelet

负责维护容器的生命周期、同时也负责 Volume(CSI)和网络(CNI)的管理


Container Runtime

负责镜像管理以及 pod 和容器的真正运行 (CRI)


Kube-Proxy

负责为 service 提供 cluster 内部的服务发现和负载均衡



工作流</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2020/08/10/k8s/k8s-probe/" title="「Kubernetes 拾遗」之 Probe（探针）"><img class="post_bg" src="https://graph.linganmin.cn/200823/cedb311450bb165121fd1f1a6d49fa13?x-oss-process=image/format,webp/quality,q_10" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="「Kubernetes 拾遗」之 Probe（探针）"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/08/10/k8s/k8s-probe/" title="「Kubernetes 拾遗」之 Probe（探针）">「Kubernetes 拾遗」之 Probe（探针）</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-08-10T14:40:34.000Z" title="发表于 2020-08-10 22:40:34">2020-08-10</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Kubernetes/">Kubernetes</a></span></div><div class="content">Kubernetes 中的健康检查是使用存活性探针和就绪性探针来实现的，基于这两种探测机制，实现了 k8s 的自愈能力。可以做到：

异常节点(pod)自动剔除，并重建
安全的滚动升级策略

存活性探针livenessProbe用于判断当前容器是否存活(running)状态，如果livenessProbe探测到容器不健康，则kubectl会杀掉该容器，并根据容器的重启策略做相应重启操作。

如果一个容器不包含livenessProbe，那么kubectl会始终认为该容器的存活性探针返回的永远是success状态。

就绪性探针readinessProbe用于判断当前容器是否完成启动(read状态)，如果readinessProbe探测到容器不健康，则判定该容器不可接收流量，Endpoint Controller将从该服务对应的Service的endpoints中移除该容器的endpoint。
探测方式
HTTP
TCP
Exec 命令

实际在生产环境使用livenessProbe12345678910livenessProbe:    httpGet:      path: /pin ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2020/08/07/golang/golang-channel/" title="「深入学习 Golang」之 Channel"><img class="post_bg" src="https://graph.linganmin.cn/201007/87122d3084205a5821b1e39413e84349?x-oss-process=image/format,webp/quality,q_10" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="「深入学习 Golang」之 Channel"></a></div><div class="recent-post-info"><a class="article-title" href="/2020/08/07/golang/golang-channel/" title="「深入学习 Golang」之 Channel">「深入学习 Golang」之 Channel</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-08-06T21:30:20.000Z" title="发表于 2020-08-07 05:30:20">2020-08-07</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Golang/">Golang</a></span></div><div class="content">设计原理
不要通过共享内存的方式进行通信，而应该通过通信的方式共享内存。

在其他语言中，多个线程传递数据的方式一般是共享内存，为了解决线程的冲突就需要限制同一时间能够读写这些变量的线程数，在 go 语言中并不需要这么做，因为 Golang 提供了一种不同的并发模型，也就是通信顺序进程（Communicating sequential process, CSP）。
Golang 中的 CSP 实现Goroutine和Channel分别对应 CSP 中的实体和传递信息的媒介。Go 语言中的Goroutine可以通过Channel传递数据。
先入先出目前的 Channel 收发操作遵循了先入先出(FIFO)的设计，具体规则如下：

先从 Channel 读取数据的 Goroutine 会先接收到数据
先向 Channel 发送数据的 Goroutine 会得到先发送数据的权力

数据结构Go 语言的 Channel 在运行时使用runtime.hchan结构体表示，我们在 Go 语言创建新的 Channel 时，实际上创建的都是如下所示的结构体：
123456789101112131415 ...</div></div></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/2/#content-inner"><i class="fas fa-chevron-left fa-fw"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/#content-inner">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/#content-inner">4</a><a class="extend next" rel="next" href="/page/4/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://graph.linganmin.cn/200118/06177d8b92c66f2c3a6fd82cca544f51" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">安小下同学</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/linganmin" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:saboranmin@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://www.weibo.com/u/1793963601" target="_blank" title="Weibo"><i class="fab fa-weibo"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">来日方短，道阻且长，好好吃饭，保重身体，任寅虎年快乐 ^_^</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/12/08/docker/log-fluentd/" title="使用 Fluentd + ElasticSearch 搭建 docker stdout 日志解决方案"><img src="https://graph.linganmin.cn/220918/09a22a20c3b33f091ac17d50dba2e259?x-oss-process=image/format,webp/quality,q_60" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用 Fluentd + ElasticSearch 搭建 docker stdout 日志解决方案"/></a><div class="content"><a class="title" href="/2022/12/08/docker/log-fluentd/" title="使用 Fluentd + ElasticSearch 搭建 docker stdout 日志解决方案">使用 Fluentd + ElasticSearch 搭建 docker stdout 日志解决方案</a><time datetime="2022-12-08T14:40:34.000Z" title="发表于 2022-12-08 22:40:34">2022-12-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/09/docker/scrolling/" title="使用 Docker Compose 实现滚动更新部署"><img src="https://graph.linganmin.cn/221209/61c7c60a1231bd6f951d4db4f6330460?x-oss-process=image/format,webp/quality,q_10" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用 Docker Compose 实现滚动更新部署"/></a><div class="content"><a class="title" href="/2022/09/09/docker/scrolling/" title="使用 Docker Compose 实现滚动更新部署">使用 Docker Compose 实现滚动更新部署</a><time datetime="2022-09-09T14:40:34.000Z" title="发表于 2022-09-09 22:40:34">2022-09-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/08/docker/log-collect/" title="使用 log-pilot + elk 搭建 docker stdout 日志解决方案"><img src="https://graph.linganmin.cn/211107/bf81612871634692c7c423dcc5aef292?x-oss-process=image/format,webp/quality,q_60" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用 log-pilot + elk 搭建 docker stdout 日志解决方案"/></a><div class="content"><a class="title" href="/2022/08/08/docker/log-collect/" title="使用 log-pilot + elk 搭建 docker stdout 日志解决方案">使用 log-pilot + elk 搭建 docker stdout 日志解决方案</a><time datetime="2022-08-08T14:40:34.000Z" title="发表于 2022-08-08 22:40:34">2022-08-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/29/k8s/k8s-sys/" title="搭建基于 Kubernetes 生产可用的日志和监控系统"><img src="https://graph.linganmin.cn/220529/b208e0a803bbec39eab9007b774f2d92?x-oss-process=image/format,webp/quality,q_10" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="搭建基于 Kubernetes 生产可用的日志和监控系统"/></a><div class="content"><a class="title" href="/2022/05/29/k8s/k8s-sys/" title="搭建基于 Kubernetes 生产可用的日志和监控系统">搭建基于 Kubernetes 生产可用的日志和监控系统</a><time datetime="2022-05-29T14:40:34.000Z" title="发表于 2022-05-29 22:40:34">2022-05-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/08/golang/memory-gc-escape/" title="浅析 Golang 内存机制（内存分配、GC、内存逃逸）"><img src="https://graph.linganmin.cn/220308/d4ae2041db5705ff090a064e92e12d78?x-oss-process=image/format,webp/quality,q_60" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="浅析 Golang 内存机制（内存分配、GC、内存逃逸）"/></a><div class="content"><a class="title" href="/2022/03/08/golang/memory-gc-escape/" title="浅析 Golang 内存机制（内存分配、GC、内存逃逸）">浅析 Golang 内存机制（内存分配、GC、内存逃逸）</a><time datetime="2022-03-08T14:30:20.000Z" title="发表于 2022-03-08 22:30:20">2022-03-08</time></div></div></div></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/Android/" style="font-size: 1.1em; color: #999">Android</a> <a href="/tags/Cache/" style="font-size: 1.1em; color: #999">Cache</a> <a href="/tags/Consul/" style="font-size: 1.1em; color: #999">Consul</a> <a href="/tags/Docker/" style="font-size: 1.5em; color: #99a9bf">Docker</a> <a href="/tags/Gin/" style="font-size: 1.1em; color: #999">Gin</a> <a href="/tags/Golang/" style="font-size: 1.37em; color: #99a4b2">Golang</a> <a href="/tags/Jeager/" style="font-size: 1.1em; color: #999">Jeager</a> <a href="/tags/Kubernetes/" style="font-size: 1.43em; color: #99a6b9">Kubernetes</a> <a href="/tags/MQ/" style="font-size: 1.17em; color: #999c9f">MQ</a> <a href="/tags/Mac/" style="font-size: 1.1em; color: #999">Mac</a> <a href="/tags/MySQL/" style="font-size: 1.17em; color: #999c9f">MySQL</a> <a href="/tags/Opentracing/" style="font-size: 1.1em; color: #999">Opentracing</a> <a href="/tags/PHP/" style="font-size: 1.1em; color: #999">PHP</a> <a href="/tags/Redis/" style="font-size: 1.1em; color: #999">Redis</a> <a href="/tags/%E4%B8%80%E5%B9%B4%E5%8F%88%E4%B8%80%E5%B9%B4/" style="font-size: 1.23em; color: #999ea6">一年又一年</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 1.17em; color: #999c9f">中间件</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 1.1em; color: #999">分布式</a> <a href="/tags/%E6%8B%BE%E9%81%97/" style="font-size: 1.3em; color: #99a1ac">拾遗</a> <a href="/tags/%E6%8C%89%E6%97%B6%E9%95%BF%E5%A4%A7/" style="font-size: 1.1em; color: #999">按时长大</a> <a href="/tags/%E6%91%84%E5%BD%B1/" style="font-size: 1.1em; color: #999">摄影</a> <a href="/tags/%E6%97%85%E8%A1%8C/" style="font-size: 1.17em; color: #999c9f">旅行</a> <a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 1.1em; color: #999">架构</a> <a href="/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/" style="font-size: 1.1em; color: #999">碎碎念</a> <a href="/tags/%E8%AF%BB%E4%B8%87%E5%8D%B7%E4%B9%A6/" style="font-size: 1.17em; color: #999c9f">读万卷书</a></div></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">40</div></div><div class="webinfo-item"><div class="item-name">已运行时间 :</div><div class="item-count" id="runtimeshow" data-publishDate="2018-12-31T16:00:00.000Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2022-12-09T14:10:23.825Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2022 By 安小下同学</div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="http://beian.miit.gov.cn/"><img style="height:10px" src="https://img.alicdn.com/imgextra/i3/O1CN012VJ8YA22JOP4XNnCr_!!6000000007099-2-tps-20-20.png">苏ICP备16006718号</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/pluginsSrc/medium-zoom/dist/medium-zoom.min.js"></script><div class="js-pjax"><script>function subtitleType () {
  if (true) { 
    window.typed = new Typed("#subtitle", {
      strings: ["诗和远方代替不了一日三餐，你的信念终究需要一个栖身之所。","好的生活应该是平静的生活，生活的理想就是理想的生活。","写代码，不含糖🍬"],
      startDelay: 300,
      typeSpeed: 150,
      loop: true,
      backSpeed: 50
    })
  } else {
    document.getElementById("subtitle").innerHTML = '诗和远方代替不了一日三餐，你的信念终究需要一个栖身之所。'
  }
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('/pluginsSrc/typed.js/lib/typed.min.js').then(subtitleType)
  }
} else {
  subtitleType()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>